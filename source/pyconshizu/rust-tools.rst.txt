Ruff ではどうするか
===================

Ruff の強みと普及
-----------------

* Rust製で高速
* flake8, isort, autoflakeなどを1つのツールに統合
* ``ruff check`` で多くの既存ルールをカバー

Ruff にはプラグイン機構がない
-----------------------------

* 2025年12月時点で、Ruffにユーザがプラグインを追加する仕組みがない
* 前章で作った flake8 プラグインは Ruff では使えない

flake8 との併用は速度を損なう
-----------------------------

* カスタムルールのために flake8 を併用する選択肢

  * Ruff の「高速さ」というメリットが薄れる
  * CIの実行時間増加

* **高速さを損なわずにカスタムルールを書く方法が求められる**

代替手段
--------

* ast-grep: tree-sitter ベースで高速、YAML でルール定義
* Rust で直接書く: RustPython/Parser を使う

Rust製ツール ast-grep
=====================

ast-grep とは
-------------

* tree-sitter ベースの構造検索・リントツール（Rust製で高速）
* YAML でルールを定義できる
* インストール: ``uvx --from ast-grep-cli ast-grep``

tree-sitter の AST は Python の AST と異なる
--------------------------------------------

* Python ``ast`` モジュール: ``ast.arg`` → ``annotation`` → ``ast.Subscript``
* tree-sitter: ``typed_parameter`` → ``type`` → ``generic_type``
* ノードの種類名・階層構造が異なる

YAML ルールの構造
-----------------

.. code-block:: yaml

    id: do-not-use-list-as-typed-parameter
    language: Python
    rule:
      pattern:
        context: 'a: list[$TYPE]'
        selector: type
      inside:
        kind: typed_parameter
    fix: Iterable[$TYPE]

YAML ルールを読み解く（1）
--------------------------

* ``pattern`` + ``context``: コード片によるパターンマッチ

  * ``$TYPE`` はメタ変数（ ``int`` などにマッチ）

* ``selector``: マッチさせたいノード種類（ ``type`` ）

YAML ルールを読み解く（2）
--------------------------

* ``inside``: 親ノードの条件（ ``typed_parameter`` ）

  * **注意**: ``inside`` は直接の親のみを見る（祖先全体ではない）

* ``fix``: 自動修正 → flake8 プラグインにはなかった強み

実行
----

.. code-block:: console

    $ ast-grep scan --rule rule.yaml examples/use_iterable.py

デバッグのコツ
--------------

* ast-grep Playground の活用

  * https://ast-grep.github.io/playground.html

* AI モデルはいずれも正しい ast-grep ルールを生成できなかった

  * ツールを人間が理解する価値がここにある

補足：tree-sitter
-----------------

* ast-grep の裏側にあるパーサーライブラリ
* 多言語対応、インクリメンタルパース
* ast-grep の YAML ルールは、裏で tree-sitter クエリとして動いている

tree-sitter クエリの例
----------------------

.. code-block:: scheme

    (typed_parameter
      (identifier) @param_name
      type: (type
        (generic_type
          (identifier) @type_name
          (type_parameter
            (type
              (identifier) @inner_type))))
      (#eq? @type_name "list"))

* ast-grep を使うだけなら直接書く必要はない
* ルールのデバッグやノード構造の理解に役立つ

発展：Rust で書く
=================

この部分だけ Rust の知識を前提にします
---------------------------------------

* 雰囲気だけ掴んでいただければ！

RustPython/Parser とは
----------------------

* RustPython や Ruff が内部で使う Python パーサー（Rust製）
* Ruff のルールも、このパーサーが生成する AST を扱っている

Rust 環境の最小限セットアップ
-----------------------------

* ``cargo`` は Python でいう ``pip`` + ``venv`` に相当
* ``cargo init`` でプロジェクト作成
* ``cargo add rustpython-parser`` で依存追加

Python コードを Rust でパースする
---------------------------------

* Python 側: ``ast.dump(ast.parse(source))``
* Rust 側: ``parse(source, Mode::Module)`` + ``println!("{:#?}", ast)``

AST 表現の比較
--------------

* Python の AST と Rust の AST は同じ概念を異なる表現で持つ

  * Python: ``FunctionDef``, ``arg``, ``Subscript``
  * Rust: ``StmtFunctionDef``, ``Parameter``, ``Expr::Subscript``

* この AST を辿って、Python版と同様の判定ロジックを Rust で書ける
